# 1 操作系统引论

## 1.1 操作系统的目标和作用

操作系统定义：是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户使用的程序集合

操作系统的目标：

* 方便性：操作系统使计算机易于使用
* 有效性：操作系统允许以更有效的方式使用计算机系统资源：提高系统资源利用率和吞吐量
* 可扩展性：操作系统中允许有效地开发、测试和引进新的系统功能
* 开放性：实现应用程序的可移植性和互操作性，要求具有统一的开放的环境

OS的作用

* OS作为用户与计算机硬件系统之间的接口

  * 计算机用户需要的用户命令
  * 应用软件需要的System Call

  > 最底层调用的是System Call，OS接口就是一些系统调用函数，如fork、open等

* OS作为计算机系统资源的管理者（软硬件资源）：处理机管理、存储器管理、I/O设备管理、文件管理。多用户系统选要多路复用

  * 时间上复用：一种资源在时间上复用时，不同程序轮流使用；例如CPU、打印机
  * 空间上复用：每个都得到资源的一部分；如内存、磁盘

* OS用作扩充机器

## 1.2 操作系统发展过程

无操作系统：人工操作方式、脱机输入输出方式

单道批处理系统

* 特征：自动性、顺序性、单道性
* 优点：减少人工操作，解决了作业的自动接续
* 缺点：平均周转时间长，没有交互能力

多道批处理系统：注意计算，执行与中断画时间图（A中断>B执行也要等A中断完再C执行）

* 特征：多道性、无序性、调度性
* 优点：提高了资源利用率和吞吐能力
* 缺点：平均周转时间长，没有交互能力

> 在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。（你走我停）

分时操作系统：及时接收、及时处理

* 特点：多路性、独立性、及时性、交互性

实时操作系统：响应及时、可靠性高

* 分类：按任务执行周期性划分为非周期性实时任务和周期性实时任务，按截止时间划分为硬实时任务、软实时任务
* 特征：多路性、独立性、交互性、可靠性、及时性

## 1.3 操作系统的基本特征

现代OS基本特征

* 并发性（最重要）：<u>并行性（同一时刻）和并发性（同一时间间隔内）</u>，并发执行的过程。
  * 进程<u>（资源分配的基本单位）</u> → 多个程序能并发执行；线程<u>（独立运行和调度的基本单位）</u>
* 共享性：互斥共享（每一个时间点只允许一个进程访问使用）、同时访问（微观上是进程交互使用）
* 虚拟性：时分复用、空分复用
* 异步性：多进程并发时我们没法知道程序运行的顺序、时间等；执行结果不确定，程序不可再现

<u>并发和共享是操作系统的两个最基本的特征</u>，他们又是互为存在的条件

## 1.4 操作系统的主要功能

操作系统主要任务、五个方面功能（CPU、存储器、设备、文件管理、方便用户使用的用户接口）

## 1.5 OS结构设计

* 无结构OS
* 模块化OS结构（模块-接口）：块与块的相互关系、优缺点

* 分层式OS结构
  * 层与层的关系：不依赖其上只依赖其下，下层为上层提供一个接口。理解成一个树形结构
  * 层次设置考虑的因素：程序嵌套；运行频率（越活跃的放底层，靠近硬件效率高）；公用模块（放底层方便所有上层调用）、用户接口
* 微内核OS结构
  * 开机后常驻内存，<u>尽可能把内核功能移到用户空间，用户模块间的通信使用消息通信</u>

课后作业：[操作系统-第1章习题解析 - 梦如三 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dpSolitude/p/11849359.html)

# 2 进程管理

<u>执行程序是计算机的基本任务</u>，程序执行的关键在PC的调用

进程→进程管理块PCB

## 2.1 前驱图和程序执行

程序执行方式：顺序——单道批处理、并发——多道批处理

* 应用级并发（应用程序）、系统级并发（操作系统自身软件）

前驱图DAG：有向无循环图，<u>无循环！！！</u>

* 结点：一条语句/一个程序段
* 有向边：结点间的前驱关系，P<sub>i</sub> 在 P<sub>j</sub> 前完成→ i 直接前驱/ j 直接后继

顺序执行：输入→计算→打印。特征（顺序、封闭、可再现）

并发执行：I<sub>i+1</sub> 和 C<sub>i</sub> 重叠→并发执行。特征（间断、失去封闭、不可再现）

* 特征：间断、失去封闭、不可再现性

## 2.2 进程的描述

定义、程序段+数据段+PCB=进程实体

创建进程实质是创建PCB 

特征：动态性（<u>程序静态进程动态</u>）、并发性、独立性、异步性

状态：就绪、执行、阻塞状态（执行时）；另外还有创建、终止

* <u>进程状态是唯一的</u>
* 就绪：静止就绪在外存，就绪在内存。静止的要先进内存才能激活

挂起/静止：静止就绪、静止阻塞；挂起原语、激活原语；挂起会从内存转换到外存，让出CPU

* 谁挂起的谁来唤醒
* 挂起的原因、特征

```mermaid
graph LR 
	活动就绪/阻塞 --挂起原语--> 静止就绪/阻塞
	静止就绪/阻塞 --激活原语--> 活动就绪/阻塞
```

进程映像：一个进程的程序、数据、栈、属性

进程控制块PCB

* 常驻内存；<u>是进程的唯一标识</u>
* 内容：进程标识符（内、外部），处理机状态，进程调度信息，进程控制信息
* 组织方式：线性、链接、索引

## 2.3 操作系统对进程的控制

进程控制：OS内一组原语来实现

原语：操作系统内核或微核提供核外调用的过程或函数

* <u>执行过程不能中断</u>
* 原子操作：不能被其它进程打断

内核：第一层扩充软件

CPU工作模式：特权模式、用户模式

* 只有操作系统工作在特权模式下，可以直接访问硬件

处理器两种执行状态：系统态（<u>进程控制功能工作在系统态</u>）、用户态

进程：系统进程、用户进程

内核功能：支撑（中断、时钟、原语）、资源管理（进程、存储器、设备）

用户登录、作业调度、提供服务、应用请求→进程创建→撤销

* fork()：返回父进程、子进程

进程终止：正常（return、exit）、异常（about、信号Ctrl+C）、外界干预

* 终止过程
* 进程由父进程创建，不能无缘无故出现。不能自己撤销（解挂）

进程阻塞与唤醒

* 原因
* 阻塞过程：block→阻塞队列→重新调度（尽量不要让CPU空闲）
* 阻塞是主动的，唤醒是被动的
* 唤醒过程：组赛队列→就绪队列

进程挂起与激活

* suspend()，活动→静止，挂起将CPU调度标值为“真”（就是允许其他进程进入CPU执行）
* 只能挂起自己或子进程
* 阻塞和挂起：都让进程暂停、释放CPU；阻塞是资源导致的，挂起可以是用户决定；阻塞还在内存，挂起就去外存了；阻塞等资源满足就恢复，挂起等将起挂起的对象来激活

抢占策略

> 如果单处理器系统中有N个进程，运行的进程最多几个，最少几个？就绪进程最多几个，最少几个？
>
> 答：运行状态最多1个，最少0个；就绪状态最多N-1个，最少0个。有就绪说明已经有运行，换成阻塞就最多N个了

## 2.4 进程的同步

有交互的（执行要依赖其他进程状况）并发会破坏封闭性、可再现性

区分并发、并行，一个核一个并行

并发进程之间的关系：互斥（不能同时使用一个资源）、同步（存在时序关系）、通信

* 互斥下，需要对共享变量做限制。临界资源/临界区，进入临界区加锁
  * 临界区使用原则：空闲让进、忙则等待（一次一个）、有限等待。临界区会减少并发

实现“上锁”：信号量机制

* 基本原理
* 分类：互斥信号量/资源信号量（<u>先申请资源再申请信号，不然死锁</u>），整型信号量/记录型信号量/AND型信号量/信号量集
  * 原子操作：wait/signal（进程执行signal原语时，有责任唤醒一个阻塞进程），<u>成对用</u>；PV操作，.value的绝对值等于该信号量阻塞队列中的等待进程数；Down/Up
* 信号量-多个进程共享一类资源，AND-同时需要多类资源，信号量集-同时要多类、每种数目不一样
* 前驱关系←→信号量（代码）

<u>上锁一定记得释放</u>

硬件同步机制

管程

## 2.5 经典同步问题

生产者/消费者问题

哲学家问题

读者/写者问题

## 2.6 进程通信

通信机制

* 低级通信
* 高级通信：共享存储器系统、管道通信（互斥、同步、确认）、消息传递系统

# 3 处理机调度与死锁

## 3,1 处理机调度层次

作业JOB、作业步、作业控制块JCB

高级调度

* 多道程序步度、周转时间、吞吐量
* 用于批处理系统

<u>批处理系统需要有作业调度，分时和实时系统无需此调度</u>

高级调度对象——作业，低级调度对象——进程

低级/进程/短程调度

* 调度方式
  * 抢占：严格的实时任务需求。原则
  * 非抢占：完成/阻塞才转让。引起的因素。优缺点
* 三个机制：排队器、分配器、上下文切换机制

中级调度

进程调度在内存中，不会出来

## 3.2 调度队列模型和调度准则 

仅有进程调度：分时系统中通常只有进程调度

有高级和低级调度：批处理系统需要进程调度和作业调度。处理机分给就绪队列首进程。设置多个阻塞队列，高优先权优先调度

三级调度都有：对系统、用户的准则（注意响应时间是提交请求到系统响应的时间，不是执行完的时间）

调度时机

进程切换：基本步骤

## 3.3 调度算法

先来先服务调度算法FCFS

* 带权周转时间=周转时间÷服务时间

短作业优先调度算法SPF

* 别把还没到达的也算进去了

> 计算的这些时间都是预估的

最短剩余时间调度算法SRT

* 执行一个的时候可能被打断（只要完成后面的时间更短），算的时候一单位时间的看，每过一个单位时间看有没有能更早结束的

优先权调度算法PSA

* 抢占、非抢占
* 优先权确定
  * 静态：系统>用户，对资源的需求，用户要求。权高先执行
  * 动态：可以防止长作业长时间垄断
* 高响应比优先调度算法HRRN（动态优先权机制）

  * 响应比 =（等待时间+要求服务时间）÷ 要求服务时间 = 响应时间 ÷ 要求服务时间
  * 每次新进程达到就计算
  * 新到达的具有优先权（没理解啥意思）
  * 一些计算：优先权=（当前时间-到达时间+服务时间）÷服务时间，周转时间=完成时间-到达时间，带权周转时间=周转时间÷服务时间

基于时间片的轮转调度

* 先按先来先服务，给定时间内执行不完的直接中断然后送去就绪队列末尾（时间片设置是针对每次执行一个进程的）
* 注意到达时间，在D到达前B已经因为大于时间片被放于队尾，顺序是CBD而不是CDB
* 到达的先进队尾，上一次没执行完的再放队尾

混合多种调度算法

* 多级队列调度算法：不同队列不同调度方法，前台一般时间片后台一般优先权或短作业
* 多级反馈队列：任务可以在队列之间移动
  * 先进第一队列末尾按FCFS，时间片内未完成就去下一个队列，第n队列就按时间片轮转。前面队列都空了才调这个队列

基于公平原则的调度算法

优先级一样时，不同OS规则不一样，做题没说先按后来的优先级高

## 3.4 实时调度

基本条件

最早截止时间优先EDF

最低松弛度优先LLF

* 松弛度=完成截止时间-剩余运行时间-当前时间
* 松弛度不降到0不抢占

优先级倒置

## 3.5 死锁

<u>银行家算法</u>

期中：简答5、计算2、程序填空1


# 4 存储器管理

