# 1 操作系统引论

## 1.1 操作系统的目标和作用

操作系统定义：是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户使用的程序集合

操作系统的目标：

* 方便性：操作系统使计算机易于使用
* 有效性：操作系统允许以更有效的方式使用计算机系统资源：提高系统资源利用率和吞吐量
* 可扩展性：操作系统中允许有效地开发、测试和引进新的系统功能
* 开放性：实现应用程序的可移植性和互操作性，要求具有统一的开放的环境

OS的作用

* OS作为用户与计算机硬件系统之间的接口

  * 计算机用户需要的用户命令
  * 应用软件需要的System Call

  > 最底层调用的是System Call，OS接口就是一些系统调用函数，如fork、open等

* OS作为计算机系统资源的管理者（软硬件资源）：处理机管理、存储器管理、I/O设备管理、文件管理。多用户系统选要多路复用

  * 时间上复用：一种资源在时间上复用时，不同程序轮流使用；例如CPU、打印机
  * 空间上复用：每个都得到资源的一部分；如内存、磁盘

* OS用作扩充机器

## 1.2 操作系统发展过程

无操作系统：人工操作方式、脱机输入输出方式

单道批处理系统

* 特征：自动性、顺序性、单道性
* 优点：减少人工操作，解决了作业的自动接续
* 缺点：平均周转时间长，没有交互能力

多道批处理系统：注意计算，执行与中断画时间图（A中断>B执行也要等A中断完再C执行）

* 特征：多道性、无序性、调度性
* 优点：提高了资源利用率和吞吐能力
* 缺点：平均周转时间长，没有交互能力

> 在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。（你走我停）

分时操作系统：及时接收、及时处理

* 特点：多路性、独立性、及时性、交互性

实时操作系统：响应及时、可靠性高

* 分类：按任务执行周期性划分为非周期性实时任务和周期性实时任务，按截止时间划分为硬实时任务、软实时任务
* 特征：多路性、独立性、交互性、可靠性、及时性

## 1.3 操作系统的基本特征

现代OS基本特征

* 并发性（最重要）：<u>并行性（同一时刻）和并发性（同一时间间隔内）</u>，并发执行的过程。
  * 进程<u>（资源分配的基本单位）</u> → 多个程序能并发执行；线程<u>（独立运行和调度的基本单位）</u>
* 共享性：互斥共享（每一个时间点只允许一个进程访问使用）、同时访问（微观上是进程交互使用）
* 虚拟性：时分复用、空分复用
* 异步性：多进程并发时我们没法知道程序运行的顺序、时间等；执行结果不确定，程序不可再现

<u>并发和共享是操作系统的两个最基本的特征</u>，他们又是互为存在的条件

## 1.4 操作系统的主要功能

操作系统主要任务、五个方面功能（CPU、存储器、设备、文件管理、方便用户使用的用户接口）

## 1.5 OS结构设计

* 无结构OS
* 模块化OS结构（模块-接口）：块与块的相互关系、优缺点

* 分层式OS结构
  * 层与层的关系：不依赖其上只依赖其下，下层为上层提供一个接口。理解成一个树形结构
  * 层次设置考虑的因素：程序嵌套；运行频率（越活跃的放底层，靠近硬件效率高）；公用模块（放底层方便所有上层调用）、用户接口
* 微内核OS结构
  * 开机后常驻内存，<u>尽可能把内核功能移到用户空间，用户模块间的通信使用消息通信</u>

课后作业：[操作系统-第1章习题解析 - 梦如三 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dpSolitude/p/11849359.html)

# 2 进程管理

<u>执行程序是计算机的基本任务</u>，程序执行的关键在PC的调用

进程→进程管理块PCB

## 2.1 前驱图和程序执行

程序执行方式：顺序——单道批处理、并发——多道批处理

* 应用级并发（应用程序）、系统级并发（操作系统自身软件）

前驱图DAG：有向无循环图，<u>无循环！！！</u>

* 结点：一条语句/一个程序段
* 有向边：结点间的前驱关系，P<sub>i</sub> 在 P<sub>j</sub> 前完成→ i 直接前驱/ j 直接后继

顺序执行：输入→计算→打印。特征（顺序、封闭、可再现）

并发执行：I<sub>i+1</sub> 和 C<sub>i</sub> 重叠→并发执行。特征（间断、失去封闭、不可再现）

* 特征：间断、失去封闭、不可再现性

## 2.2 进程的描述

定义、程序段+数据段+PCB=进程实体

创建进程实质是创建PCB 

特征：动态性（<u>程序静态进程动态</u>）、并发性、独立性、异步性

状态：就绪、执行、阻塞状态（执行时）；另外还有创建、终止

* <u>进程状态是唯一的</u>
* 就绪：静止就绪在外存，就绪在内存。静止的要先进内存才能激活

挂起/静止：静止就绪、静止阻塞；挂起原语、激活原语；挂起会从内存转换到外存，让出CPU

* 谁挂起的谁来唤醒
* 挂起的原因、特征

```mermaid
graph LR 
	活动就绪/阻塞 --挂起原语--> 静止就绪/阻塞
	静止就绪/阻塞 --激活原语--> 活动就绪/阻塞
```

进程映像：一个进程的程序、数据、栈、属性

进程控制块PCB

* 常驻内存；<u>是进程的唯一标识</u>
* 内容：进程标识符（内、外部），处理机状态，进程调度信息，进程控制信息
* 组织方式：线性、链接、索引

## 2.3 操作系统对进程的控制

进程控制：OS内一组原语来实现

原语：操作系统内核或微核提供核外调用的过程或函数

* <u>执行过程不能中断</u>
* 原子操作：不能被其它进程打断

内核：第一层扩充软件

CPU工作模式：特权模式、用户模式

* 只有操作系统工作在特权模式下，可以直接访问硬件

处理器两种执行状态：系统态（<u>进程控制功能工作在系统态</u>）、用户态

进程：系统进程、用户进程

内核功能：支撑（中断、时钟、原语）、资源管理（进程、存储器、设备）

用户登录、作业调度、提供服务、应用请求→进程创建→撤销

* fork()：返回父进程、子进程

进程终止：正常（return、exit）、异常（about、信号Ctrl+C）、外界干预

* 终止过程
* 进程由父进程创建，不能无缘无故出现。不能自己撤销（解挂）

进程阻塞与唤醒

* 原因
* 阻塞过程：block→阻塞队列→重新调度（尽量不要让CPU空闲）
* 阻塞是主动的，唤醒是被动的
* 唤醒过程：组赛队列→就绪队列

进程挂起与激活

* suspend()，活动→静止，挂起将CPU调度标值为“真”（就是允许其他进程进入CPU执行）
* 只能挂起自己或子进程
* 阻塞和挂起：都让进程暂停、释放CPU；阻塞是资源导致的，挂起可以是用户决定；阻塞还在内存，挂起就去外存了；阻塞等资源满足就恢复，挂起等将起挂起的对象来激活

抢占策略

> 如果单处理器系统中有N个进程，运行的进程最多几个，最少几个？就绪进程最多几个，最少几个？
>
> 答：运行状态最多1个，最少0个；就绪状态最多N-1个，最少0个。有就绪说明已经有运行，换成阻塞就最多N个了

## 2.4 进程的同步

有交互的（执行要依赖其他进程状况）并发会破坏封闭性、可再现性

区分并发、并行，一个核一个并行

并发进程之间的关系：互斥（不能同时使用一个资源）、同步（存在时序关系）、通信

* 互斥下，需要对共享变量做限制。临界资源/临界区，进入临界区加锁
  * 临界区使用原则：空闲让进、忙则等待（一次一个）、有限等待。临界区会减少并发

实现“上锁”：信号量机制

* 基本原理
* 分类：互斥信号量/资源信号量（<u>先申请资源再申请信号，不然死锁</u>），整型信号量/记录型信号量/AND型信号量/信号量集
  * 原子操作：wait/signal（进程执行signal原语时，有责任唤醒一个阻塞进程），<u>成对用</u>；PV操作，.value的绝对值等于该信号量阻塞队列中的等待进程数；Down/Up
* 信号量-多个进程共享一类资源，AND-同时需要多类资源，信号量集-同时要多类、每种数目不一样
* 前驱关系←→信号量（代码）

<u>上锁一定记得释放</u>

硬件同步机制

管程

## 2.5 经典同步问题

生产者/消费者问题

哲学家问题

读者/写者问题

## 2.6 进程通信

通信机制

* 低级通信
* 高级通信：共享存储器系统、管道通信（互斥、同步、确认）、消息传递系统

# 3 处理机调度与死锁

## 3,1 处理机调度层次

作业JOB、作业步、作业控制块JCB

高级调度

* 多道程序步度、周转时间、吞吐量
* 用于批处理系统

<u>批处理系统需要有作业调度，分时和实时系统无需此调度</u>

高级调度对象——作业，低级调度对象——进程

低级/进程/短程调度

* 调度方式
  * 抢占：严格的实时任务需求。原则
  * 非抢占：完成/阻塞才转让。引起的因素。优缺点
* 三个机制：排队器、分配器、上下文切换机制

中级调度

进程调度在内存中，不会出来

## 3.2 调度队列模型和调度准则 

仅有进程调度：分时系统中通常只有进程调度

有高级和低级调度：批处理系统需要进程调度和作业调度。处理机分给就绪队列首进程。设置多个阻塞队列，高优先权优先调度

三级调度都有：对系统、用户的准则（注意响应时间是提交请求到系统响应的时间，不是执行完的时间）

调度时机

进程切换：基本步骤

## 3.3 调度算法

先来先服务调度算法FCFS

* 带权周转时间=周转时间÷服务时间

短作业优先调度算法SPF

* 别把还没到达的也算进去了

> 计算的这些时间都是预估的

最短剩余时间调度算法SRT

* 执行一个的时候可能被打断（只要完成后面的时间更短），算的时候一单位时间的看，每过一个单位时间看有没有能更早结束的

优先权调度算法PSA

* 抢占、非抢占
* 优先权确定
  * 静态：系统>用户，对资源的需求，用户要求。权高先执行
  * 动态：可以防止长作业长时间垄断
* 高响应比优先调度算法HRRN（动态优先权机制）

  * 响应比 =（等待时间+要求服务时间）÷ 要求服务时间 = 响应时间 ÷ 要求服务时间
  * 每次新进程达到就计算
  * 新到达的具有优先权（没理解啥意思）
  * 一些计算：优先权=（当前时间-到达时间+服务时间）÷服务时间，周转时间=完成时间-到达时间，带权周转时间=周转时间÷服务时间

基于时间片的轮转调度

* 先按先来先服务，给定时间内执行不完的直接中断然后送去就绪队列末尾（时间片设置是针对每次执行一个进程的）
* 注意到达时间，在D到达前B已经因为大于时间片被放于队尾，顺序是CBD而不是CDB
* 到达的先进队尾，上一次没执行完的再放队尾

混合多种调度算法

* 多级队列调度算法：不同队列不同调度方法，前台一般时间片后台一般优先权或短作业
* 多级反馈队列：任务可以在队列之间移动
  * 先进第一队列末尾按FCFS，时间片内未完成就去下一个队列，第n队列就按时间片轮转。前面队列都空了才调这个队列

基于公平原则的调度算法

优先级一样时，不同OS规则不一样，做题没说先按后来的优先级高

## 3.4 实时调度

基本条件

最早截止时间优先EDF

最低松弛度优先LLF

* 松弛度=完成截止时间-剩余运行时间-当前时间
* 松弛度不降到0不抢占

优先级倒置

## 3.5 死锁

<u>银行家算法</u>

期中：简答5、计算2、程序填空1


# 4 存储器管理

> 重难点：
>
> * 重定位的基本概念：为什么要引入
> * 如何提高内存利用率：离散分配、对换机制、动态链接、虚拟存储器、存储器共享动态分区分配方式：分配、回收算法
> * 基本分页存储管理方式：为什么引入；地址变换机构和过程（含具有快表的情况）
> * 基本分段存储管理方式：为什么引入；地址变换机构和过程（含具有快表的情况）；信息的共享和保护
> * 虚拟存储器的基本概念：为什么要引入；特征；实现虚拟存储的关键技术
> * 请求分页系统的基本原理：页表机制；地址变换过程；页面置换算
> * 访问内存的有效时间
>
> 典型问题：
>
> * 存储器管理的基本任务
> * 动态重定位的概念、实现方式，什么情况下需要重定位
> * 比较连续分配与离散分配
> * 基于空闲分区链的内存分配与回收算法的应用实例：首次适应法，循环首次适应法，最佳适应法、最坏适应法
> * 在某分页系统中，给定内存容量和物理块大小，计算物理块的数量；对给定的进程页表，将给定的逻辑地址，计算出其对应的物理地址并画出地址变换流程图。
> * 在某分段系统中对给定的进程段表，将给定的逻辑地址，计算出其对应的物理地址并画出地址变换流程图。
> * 请求分页系统过程的各种问题，并用流程图的方式表示地址变换过程
> * 对给定的问题，按各种页面置换算法，写页面调入过程，计算和分析缺页率，并对多种算法的性能作比较分析

## 4.1 存储器的层次结构

> 存储器的层次结构——寄存器、高速缓存、内存、磁盘缓存、磁盘

主存储器/内存：用于保存进程运行时的程序和数据。CPU的控制部件只能从主存中取得指令和数据到CPU寄存器，同样，CPU寄存器中的数据可存入主存。  CPU与外设交换数据必须依托于主存。 

寄存器：寄存器访问速度最快，与CPU协调工作。

高速缓存：CPU对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。 根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。 有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。

磁盘缓存：内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）。

存储器管理的目的和功能：

1. 主存储器的分配和管理
2. 提高主存储器的利用率
3. “扩充”主存容量：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间。
4. 存储保护

存储分配

* 直接指定方式，缺点
* 静态分配方式，特点
* 动态分配方式，特点

## 4.2 程序的装入和链接

编译（编译程序接受完整的源一级的程序，并以类似于成批的方式生成完整的目标一级的模块）→链接（链接程序实现将目标模块链接成装入模块）→装入（装入程序将装入模块装入内存并执行）

装入：

* 绝对装入方式
* 可重定位装入方式（重定位）

重定位：经编译得到的目标模块中为相对地址（通常从0开始），即地址都是相对于0开始的。装入模块中的逻辑地址与实际装入内存的物理地址不同。装入内存时，相对地址（数据、指令地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为重定位。

静态重定位：装入内存时一次完成。适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置

* 物理地址=相对地址+内存中的起始地址​

* 优缺点

动态运行时装入方式/动态重定位：装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换

* 实现：利用一个重定位寄存器（RR），该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。
* 优缺点

链接：将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块

* 静态链接
* 装入时动态链接
* 运行时动态链接（最常用）

## 4.3 连续分配方式

连续分配：为用户程序分配的一个连续的内存空间

* 单一连续分配：单用户系统在一段时间内，只有一个进程在内存，故内存分配管理十分简单，内存利用率低。内存分为两个区域，一个供操作系统使用（系统区），一个供用户使用（用户区）

  * 优点：易于管理
  * 缺点：①对要求内存空间少的程序，造成内存浪费；②程序全部装入，很少使用的程序部分也占用内存

* 分区式分配：系统把内存用户区划分为若干分区，分区大小可以相等，也可以不等。一个进程占据一个分区。这是早期用于多道程序的一种较简单的存储管理方式。有一张分区说明表，指出分配的分区数、大小、起始地址、状态（是否已分配）

  * 固定分区：分区表记录分区大小和使用情况

    ①优点：易于实现，开销小。

    ②缺点：内碎片造成浪费。分区总数固定，限制了并发执行的程序数目。存储空间利用率低

  * 动态（可变）分区（见下文）

* 可重定位分区分配（见下文）

> 内零头/内碎片：内存中已分配给用户但未被利用的区域
>
> 外零头：没有分配但无法分配的空间，大小而无法分配

动态分区分配：

* 方案：分区数目固定、分区数目可变

* 数据结构：空闲分区表、空闲分区链

* 分区分配算法：前4个基于顺序搜索，后2个基于索引搜索。各个算法都有优缺点

  1. 最佳适应算法(Best Fit)：选择大小最接近的存储区域

  2. 最坏适应算法(Worst Fit)：选择最大的空白区，往往导致剩下的空白区也是最大的

  3. 首次适应算法(First Fit)：空白区地址递增构成顺序链，选链上第一个满足的空白块

  4. 循环首次（下次）适应算法(Next Fit)/带旋转指针的首次适应算法：空白快构成循环链，从上次查找结束位置足够大的空白区就划出去分配

  5. 快速适应算法(Quick Fit)：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可

  6. 伙伴系统

     ```
     首先计算一个 i 值，使 2^(i－1) < n ≤ 2^i；
     在空闲分区大小为 2^i 的空闲分区链表中查找。
     if  找到，即把该空闲分区分配给进程。
     else  在分区大小为2i＋1的空闲分区链表中寻找;
     	//表明长度为2i的空闲分区已经耗尽
     	if  找到大小为2i＋1 的空闲分区
         	把该空闲分区分为相等的两个分区（一对伙伴），其中一个用于分配，另一个加入分区大小为 2i 的空闲分区链表中。
     	else  查找大小为2i＋2 的空闲分区……
     ```

* 分区分配操作：分配内存、回收内存（与前一个空闲分区邻接向上合并、与下面的邻接向下合并、上下邻接合并三个、均不邻接新建）

> PPT上的题，没看懂
>
> ![image-20230608195502292](https://github.com/LyrisLaurier/notes/assets/94295495/1c5d0e81-935c-4364-a1d4-a921c711e366)


哈希算法：利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张哈希表，以空闲分区大小为关键字，每一个表项记录了一个对应的空闲分区链表表头指针

可重定位分区分配

* 紧凑：可以合并小分区
* 动态重定位

## 4.4 基本分页存储管理方式

离散分配：程序在内存中不一定连续存放

- 分页存储管理
- 分段存储管理
- 段页式存储管理

离散-分页、分块→优点：没有外零头，仅有一个小于页面的内零头

> 系统中页块大小不变

页面大小：一种机器只采用一种大小的页面（小页面/大页面-1KB~8KB）

数据结构

* 页表：每个进程对应 1 个页表，描述该进程的各页面在内存中对应的物理块号。包括页号、物理块号、还可能有存取控制字段
* 作业表：整个系统1张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息
* 空闲块表：整个系统1张，记录主存当前空闲块

地址变换机构：逻辑地址（页号+页内偏移量）→物理地址（物理块号+物理块内的偏移），二者大小一样因此偏移量一致，关键是由页表完成页号到物理块号的转换

* 使用寄存器存放页表
* 将页表存储在内存中：页表寄存器PTR，记录当前运行的进程的页表在内存中的始址和页表长度。（平时存于PCB中，要运行时才装入PTR中）

分页系统的地址变换过程

1. 根据逻辑地址计算处页号和页内偏移量
2. 从PTR中得到页表首址，然后检索页表，查找指定页面对应的页框号
3. 用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端
4. 将页内偏移量送入物理地址低端，形成完整的物理地址

PPT上的一个题（还有俩类似的）

![OF177{0Y1}ZH{8`WQ}1@M`7](https://github.com/LyrisLaurier/notes/assets/94295495/5bccc2a7-4b4c-4113-b860-1a0a2560f424)  

具有快表的地址变换机构：为进程页表设置一个专用的高速缓冲存储器-快表TLB/联想存储器，专门保存当前进程最近访问过的一组页表项

命中、不命中、命中率

访问内存有效时间EAT：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间

平均存取时间计算：访问内存时间t1，检索快表时间t2

* 命中：耗费时间是 t1+t2
* 不命中：耗费时间就是 t1+t2+t2
* 因此平均存取时间就是 $(t1+t2)×命中率+(t1+t2+t2)×(1-命中率)$ 

二级页表：页表过多没有足够大的连续空间

多级页表：64位机器一般采用多级页表（4级以上）

反置页表IPT：避免一个进程一个页表，一般采用Hash表来检索。IPT是为主存中的每一个物理块建立一个页表项并按照块号排序；该表每个表项包含正在访问该物理块的进程标识、页号及特征位,用来完成主存物理块到访问进程的页号的转换。

* 地址转换过程：给出进程标识和页号,用它们去比较IPT,若整个反置页表中未能找到匹配的页表项,说明该页不在主存,产生请求调页中断,请求操作系统调入;否则，该表项的序号便是物理块号,块号加上位移,便形成物理地址。

> 反置页表没看懂
 
## 4.5 分段式存储管理


