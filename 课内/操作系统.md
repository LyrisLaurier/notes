*****

# 1 操作系统引论

## 1.1 操作系统的目标和作用

操作系统定义：是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户使用的程序集合

操作系统的目标：

* 方便性：操作系统使计算机易于使用
* 有效性：操作系统允许以更有效的方式使用计算机系统资源：提高系统资源利用率和吞吐量
* 可扩展性：操作系统中允许有效地开发、测试和引进新的系统功能
* 开放性：实现应用程序的可移植性和互操作性，要求具有统一的开放的环境

OS的作用

* OS作为用户与计算机硬件系统之间的接口

  * 计算机用户需要的用户命令
  * 应用软件需要的System Call

  > 最底层调用的是System Call，OS接口就是一些系统调用函数，如fork、open等

* OS作为计算机系统资源的管理者（软硬件资源）：处理机管理、存储器管理、I/O设备管理、文件管理。多用户系统选要多路复用

  * 时间上复用：一种资源在时间上复用时，不同程序轮流使用；例如CPU、打印机
  * 空间上复用：每个都得到资源的一部分；如内存、磁盘

* OS用作扩充机器

## 1.2 操作系统发展过程

无操作系统：人工操作方式、脱机输入输出方式

单道批处理系统

* 特征：自动性、顺序性、单道性
* 优点：减少人工操作，解决了作业的自动接续
* 缺点：平均周转时间长，没有交互能力

多道批处理系统：注意计算，执行与中断画时间图（A中断>B执行也要等A中断完再C执行）

* 特征：多道性、无序性、调度性
* 优点：提高了资源利用率和吞吐能力
* 缺点：平均周转时间长，没有交互能力

> 在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。（你走我停）

分时操作系统：及时接收、及时处理

* 特点：多路性、独立性、及时性、交互性

实时操作系统：响应及时、可靠性高

* 分类：按任务执行周期性划分为非周期性实时任务和周期性实时任务，按截止时间划分为硬实时任务、软实时任务
* 特征：多路性、独立性、交互性、可靠性、及时性

## 1.3 操作系统的基本特征

现代OS基本特征

* 并发性（最重要）：<u>并行性（同一时刻）和并发性（同一时间间隔内）</u>，并发执行的过程。
  * 进程<u>（资源分配的基本单位）</u> → 多个程序能并发执行；线程<u>（独立运行和调度的基本单位）</u>
* 共享性：互斥共享（每一个时间点只允许一个进程访问使用）、同时访问（微观上是进程交互使用）
* 虚拟性：时分复用、空分复用
* 异步性：多进程并发时我们没法知道程序运行的顺序、时间等；执行结果不确定，程序不可再现

<u>并发和共享是操作系统的两个最基本的特征</u>，他们又是互为存在的条件

## 1.4 操作系统的主要功能

操作系统主要任务、五个方面功能（CPU、存储器、设备、文件管理、方便用户使用的用户接口）

## 1.5 OS结构设计

* 无结构OS
* 模块化OS结构（模块-接口）：块与块的相互关系、优缺点

* 分层式OS结构
  * 层与层的关系：不依赖其上只依赖其下，下层为上层提供一个接口。理解成一个树形结构
  * 层次设置考虑的因素：程序嵌套；运行频率（越活跃的放底层，靠近硬件效率高）；公用模块（放底层方便所有上层调用）、用户接口
* 微内核OS结构
  * 开机后常驻内存，<u>尽可能把内核功能移到用户空间，用户模块间的通信使用消息通信</u>

课后作业：[操作系统-第1章习题解析 - 梦如三 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dpSolitude/p/11849359.html)

*****

# 2 进程管理

<u>执行程序是计算机的基本任务</u>，程序执行的关键在PC的调用

进程→进程管理块PCB

## 2.1 前驱图和程序执行

程序执行方式：顺序——单道批处理、并发——多道批处理

* 应用级并发（应用程序）、系统级并发（操作系统自身软件）

前驱图DAG：有向无循环图，<u>无循环！！！</u>

* 结点：一条语句/一个程序段
* 有向边：结点间的前驱关系，P<sub>i</sub> 在 P<sub>j</sub> 前完成→ i 直接前驱/ j 直接后继

顺序执行：输入→计算→打印。特征（顺序、封闭、可再现）

并发执行：I<sub>i+1</sub> 和 C<sub>i</sub> 重叠→并发执行。特征（间断、失去封闭、不可再现）

* 特征：间断、失去封闭、不可再现性

## 2.2 进程的描述

定义、程序段+数据段+PCB=进程实体

创建进程实质是创建PCB 

特征：动态性（<u>程序静态进程动态</u>）、并发性、独立性、异步性

状态：就绪、执行、阻塞状态（执行时）；另外还有创建、终止

* <u>进程状态是唯一的</u>
* 就绪：静止就绪在外存，就绪在内存。静止的要先进内存才能激活

挂起/静止：静止就绪、静止阻塞；挂起原语、激活原语；挂起会从内存转换到外存，让出CPU

* 谁挂起的谁来唤醒
* 挂起的原因、特征

```mermaid
graph LR 
	活动就绪/阻塞 --挂起原语--> 静止就绪/阻塞
	静止就绪/阻塞 --激活原语--> 活动就绪/阻塞
```

进程映像：一个进程的程序、数据、栈、属性

进程控制块PCB

* 常驻内存；<u>是进程的唯一标识</u>
* 内容：进程标识符（内、外部），处理机状态，进程调度信息，进程控制信息
* 组织方式：线性、链接、索引

## 2.3 操作系统对进程的控制

进程控制：OS内一组原语来实现

原语：操作系统内核或微核提供核外调用的过程或函数

* <u>执行过程不能中断</u>
* 原子操作：不能被其它进程打断

内核：第一层扩充软件

CPU工作模式：特权模式、用户模式

* 只有操作系统工作在特权模式下，可以直接访问硬件

处理器两种执行状态：系统态（<u>进程控制功能工作在系统态</u>）、用户态

进程：系统进程、用户进程

内核功能：支撑（中断、时钟、原语）、资源管理（进程、存储器、设备）

用户登录、作业调度、提供服务、应用请求→进程创建→撤销

* fork()：返回父进程、子进程

进程终止：正常（return、exit）、异常（about、信号Ctrl+C）、外界干预

* 终止过程
* 进程由父进程创建，不能无缘无故出现。不能自己撤销（解挂）

进程阻塞与唤醒

* 原因
* 阻塞过程：block→阻塞队列→重新调度（尽量不要让CPU空闲）
* 阻塞是主动的，唤醒是被动的
* 唤醒过程：组赛队列→就绪队列

进程挂起与激活

* suspend()，活动→静止，挂起将CPU调度标值为“真”（就是允许其他进程进入CPU执行）
* 只能挂起自己或子进程
* 阻塞和挂起：都让进程暂停、释放CPU；阻塞是资源导致的，挂起可以是用户决定；阻塞还在内存，挂起就去外存了；阻塞等资源满足就恢复，挂起等将起挂起的对象来激活

抢占策略

> 如果单处理器系统中有N个进程，运行的进程最多几个，最少几个？就绪进程最多几个，最少几个？
>
> 答：运行状态最多1个，最少0个；就绪状态最多N-1个，最少0个。有就绪说明已经有运行，换成阻塞就最多N个了

## 2.4 进程的同步

有交互的（执行要依赖其他进程状况）并发会破坏封闭性、可再现性

区分并发、并行，一个核一个并行

并发进程之间的关系：互斥（不能同时使用一个资源）、同步（存在时序关系）、通信

* 互斥下，需要对共享变量做限制。临界资源/临界区，进入临界区加锁
  * 临界区使用原则：空闲让进、忙则等待（一次一个）、有限等待。临界区会减少并发

实现“上锁”：信号量机制

* 基本原理
* 分类：互斥信号量/资源信号量（<u>先申请资源再申请信号，不然死锁</u>），整型信号量/记录型信号量/AND型信号量/信号量集
  * 原子操作：wait/signal（进程执行signal原语时，有责任唤醒一个阻塞进程），<u>成对用</u>；PV操作，.value的绝对值等于该信号量阻塞队列中的等待进程数；Down/Up
* 信号量-多个进程共享一类资源，AND-同时需要多类资源，信号量集-同时要多类、每种数目不一样
* 前驱关系←→信号量（代码）

<u>上锁一定记得释放</u>

硬件同步机制

管程

## 2.5 经典同步问题

生产者/消费者问题

哲学家问题

读者/写者问题

## 2.6 进程通信

通信机制

* 低级通信
* 高级通信：共享存储器系统、管道通信（互斥、同步、确认）、消息传递系统

*****

# 3 处理机调度与死锁

## 3.1 处理机调度层次

作业JOB、作业步、作业控制块JCB

高级调度

* 多道程序步度、周转时间、吞吐量
* 用于批处理系统

<u>批处理系统需要有作业调度，分时和实时系统无需此调度</u>

高级调度对象——作业，低级调度对象——进程

低级/进程/短程调度

* 调度方式
  * 抢占：严格的实时任务需求。原则
  * 非抢占：完成/阻塞才转让。引起的因素。优缺点
* 三个机制：排队器、分配器、上下文切换机制

中级调度

进程调度在内存中，不会出来

## 3.2 调度队列模型和调度准则 

仅有进程调度：分时系统中通常只有进程调度

有高级和低级调度：批处理系统需要进程调度和作业调度。处理机分给就绪队列首进程。设置多个阻塞队列，高优先权优先调度

三级调度都有：对系统、用户的准则（注意响应时间是提交请求到系统响应的时间，不是执行完的时间）

调度时机

进程切换：基本步骤

## 3.3 调度算法

先来先服务调度算法FCFS

* 带权周转时间=周转时间÷服务时间

短作业优先调度算法SPF

* 别把还没到达的也算进去了

> 计算的这些时间都是预估的

最短剩余时间调度算法SRT

* 执行一个的时候可能被打断（只要完成后面的时间更短），算的时候一单位时间的看，每过一个单位时间看有没有能更早结束的

优先权调度算法PSA

* 抢占、非抢占
* 优先权确定
  * 静态：系统>用户，对资源的需求，用户要求。权高先执行
  * 动态：可以防止长作业长时间垄断
* 高响应比优先调度算法HRRN（动态优先权机制）

  * 响应比 =（等待时间+要求服务时间）÷ 要求服务时间 = 响应时间 ÷ 要求服务时间
  * 每次新进程达到就计算
  * 新到达的具有优先权（没理解啥意思）
  * 一些计算：优先权=（当前时间-到达时间+服务时间）÷服务时间，周转时间=完成时间-到达时间，带权周转时间=周转时间÷服务时间

基于时间片的轮转调度

* 先按先来先服务，给定时间内执行不完的直接中断然后送去就绪队列末尾（时间片设置是针对每次执行一个进程的）
* 注意到达时间，在D到达前B已经因为大于时间片被放于队尾，顺序是CBD而不是CDB
* 到达的先进队尾，上一次没执行完的再放队尾

混合多种调度算法

* 多级队列调度算法：不同队列不同调度方法，前台一般时间片后台一般优先权或短作业
* 多级反馈队列：任务可以在队列之间移动
  * 先进第一队列末尾按FCFS，时间片内未完成就去下一个队列，第n队列就按时间片轮转。前面队列都空了才调这个队列

基于公平原则的调度算法

优先级一样时，不同OS规则不一样，做题没说先按后来的优先级高

## 3.4 实时调度

基本条件

最早截止时间优先EDF

最低松弛度优先LLF

* 松弛度=完成截止时间-剩余运行时间-当前时间
* 松弛度不降到0不抢占

优先级倒置

## 3.5 死锁

<u>银行家算法</u>

期中：简答5、计算2、程序填空1

*****

# 4 存储器管理

> 重难点：
>
> * 重定位的基本概念：为什么要引入
> * 如何提高内存利用率：离散分配、对换机制、动态链接、虚拟存储器、存储器共享动态分区分配方式：分配、回收算法
> * 基本分页存储管理方式：为什么引入；地址变换机构和过程（含具有快表的情况）
> * 基本分段存储管理方式：为什么引入；地址变换机构和过程（含具有快表的情况）；信息的共享和保护
> * 虚拟存储器的基本概念：为什么要引入；特征；实现虚拟存储的关键技术
> * 请求分页系统的基本原理：页表机制；地址变换过程；页面置换算
> * 访问内存的有效时间
>
> 典型问题：
>
> * 存储器管理的基本任务
> * 动态重定位的概念、实现方式，什么情况下需要重定位
> * 比较连续分配与离散分配
> * 基于空闲分区链的内存分配与回收算法的应用实例：首次适应法，循环首次适应法，最佳适应法、最坏适应法
> * 在某分页系统中，给定内存容量和物理块大小，计算物理块的数量；对给定的进程页表，将给定的逻辑地址，计算出其对应的物理地址并画出地址变换流程图。
> * 在某分段系统中对给定的进程段表，将给定的逻辑地址，计算出其对应的物理地址并画出地址变换流程图。
> * 请求分页系统过程的各种问题，并用流程图的方式表示地址变换过程
> * 对给定的问题，按各种页面置换算法，写页面调入过程，计算和分析缺页率，并对多种算法的性能作比较分析

## 4.1 存储器的层次结构

> 存储器的层次结构——寄存器、高速缓存、内存、磁盘缓存、磁盘

主存储器/内存：用于保存进程运行时的程序和数据。CPU的控制部件只能从主存中取得指令和数据到CPU寄存器，同样，CPU寄存器中的数据可存入主存。  CPU与外设交换数据必须依托于主存。 

寄存器：寄存器访问速度最快，与CPU协调工作。

高速缓存：CPU对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。 根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。 有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。

磁盘缓存：内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）。

存储器管理的目的和功能：

1. 主存储器的分配和管理
2. 提高主存储器的利用率
3. “扩充”主存容量：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间。
4. 存储保护

存储分配

* 直接指定方式，缺点
* 静态分配方式，特点
* 动态分配方式，特点

## 4.2 程序的装入和链接

编译（编译程序接受完整的源一级的程序，并以类似于成批的方式生成完整的目标一级的模块）→链接（链接程序实现将目标模块链接成装入模块）→装入（装入程序将装入模块装入内存并执行）

装入：

* 绝对装入方式
* 可重定位装入方式（重定位）

重定位：经编译得到的目标模块中为相对地址（通常从0开始），即地址都是相对于0开始的。装入模块中的逻辑地址与实际装入内存的物理地址不同。装入内存时，相对地址（数据、指令地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为重定位。

静态重定位：装入内存时一次完成。适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置

* 物理地址=相对地址+内存中的起始地址​

* 优缺点

动态运行时装入方式/动态重定位：装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换

* 实现：利用一个重定位寄存器（RR），该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。
* 优缺点

链接：将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块

* 静态链接
* 装入时动态链接
* 运行时动态链接（最常用）

## 4.3 连续分配方式

> 连续分配方式——单一连续分配、分区分配（固定、动态）、动态重定位分区分配

连续分配：为用户程序分配的一个连续的内存空间

* 单一连续分配：单用户系统在一段时间内，只有一个进程在内存，故内存分配管理十分简单，内存利用率低。内存分为两个区域，一个供操作系统使用（系统区），一个供用户使用（用户区）

  * 优点：易于管理
  * 缺点：①对要求内存空间少的程序，造成内存浪费；②程序全部装入，很少使用的程序部分也占用内存

* 分区式分配：系统把内存用户区划分为若干分区，分区大小可以相等，也可以不等。一个进程占据一个分区。这是早期用于多道程序的一种较简单的存储管理方式。有一张分区说明表，指出分配的分区数、大小、起始地址、状态（是否已分配）

  * 固定分区：分区表记录分区大小和使用情况

    ①优点：易于实现，开销小。

    ②缺点：内碎片造成浪费。分区总数固定，限制了并发执行的程序数目。存储空间利用率低

  * 动态（可变）分区（见下文）

* 可重定位分区分配（见下文）

> 内零头/内碎片：内存中已分配给用户但未被利用的区域
>
> 外零头：没有分配但无法分配的空间，大小而无法分配

动态分区分配：

* 方案：分区数目固定、分区数目可变

* 数据结构：空闲分区表、空闲分区链

* 分区分配算法：前4个基于顺序搜索，后2个基于索引搜索。各个算法都有优缺点

  1. 最佳适应算法(Best Fit)：选择大小最接近的存储区域

  2. 最坏适应算法(Worst Fit)：选择最大的空白区，往往导致剩下的空白区也是最大的

  3. 首次适应算法(First Fit)：空白区地址递增构成顺序链，选链上第一个满足的空白块

  4. 循环首次（下次）适应算法(Next Fit)/带旋转指针的首次适应算法：空白快构成循环链，从上次查找结束位置足够大的空白区就划出去分配

  5. 快速适应算法(Quick Fit)：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可

  6. 伙伴系统

     ```
     首先计算一个 i 值，使 2^(i－1) < n ≤ 2^i；
     在空闲分区大小为 2^i 的空闲分区链表中查找。
     if  找到，即把该空闲分区分配给进程。
     else  在分区大小为2i＋1的空闲分区链表中寻找;
     	//表明长度为2i的空闲分区已经耗尽
     	if  找到大小为2i＋1 的空闲分区
         	把该空闲分区分为相等的两个分区（一对伙伴），其中一个用于分配，另一个加入分区大小为 2i 的空闲分区链表中。
     	else  查找大小为2i＋2 的空闲分区……
     ```

* 分区分配操作：分配内存、回收内存（与前一个空闲分区邻接向上合并、与下面的邻接向下合并、上下邻接合并三个、均不邻接新建）

> PPT上的题，没看懂
>
> ![image-20230608195502292](https://github.com/LyrisLaurier/notes/assets/94295495/1c5d0e81-935c-4364-a1d4-a921c711e366)


哈希算法：利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张哈希表，以空闲分区大小为关键字，每一个表项记录了一个对应的空闲分区链表表头指针

可重定位分区分配

* 紧凑：可以合并小分区
* 动态重定位

## 4.4 基本分页存储管理方式

> 离散分配方式——用户程序划分、逻辑地址、内存空间划分、内存分配、管理考虑、硬件支持、地址映射过程

离散分配：程序在内存中不一定连续存放

- 分页存储管理
- 分段存储管理
- 段页式存储管理

离散-分页、分块→优点：没有外零头，仅有一个小于页面的内零头

> 系统中页块大小不变

页面大小：一种机器只采用一种大小的页面（小页面/大页面-1KB~8KB）

数据结构

* 页表：每个进程对应 1 个页表，描述该进程的各页面在内存中对应的物理块号。包括页号、物理块号、还可能有存取控制字段
* 作业表：整个系统1张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息
* 空闲块表：整个系统1张，记录主存当前空闲块

地址变换机构：逻辑地址（页号+页内偏移量）→物理地址（物理块号+物理块内的偏移），二者大小一样因此偏移量一致，关键是由页表完成页号到物理块号的转换

* 使用寄存器存放页表
* 将页表存储在内存中：页表寄存器PTR，记录当前运行的进程的页表在内存中的始址和页表长度。（平时存于PCB中，要运行时才装入PTR中）

分页系统的地址变换过程

1. 根据逻辑地址计算处页号和页内偏移量
2. 从PTR中得到页表首址，然后检索页表，查找指定页面对应的页框号
3. 用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端
4. 将页内偏移量送入物理地址低端，形成完整的物理地址

PPT上的一个题（还有俩类似的）

![OF177{0Y1}ZH{8`WQ}1@M`7](https://github.com/LyrisLaurier/notes/assets/94295495/5bccc2a7-4b4c-4113-b860-1a0a2560f424)  

地址变换图示例

![image-20230609104232251](https://github.com/LyrisLaurier/notes/assets/94295495/3a463014-9da7-4783-a4d5-8ff5f5c5d7bc)

具有快表的地址变换机构：为进程页表设置一个专用的高速缓冲存储器-快表TLB/联想存储器，专门保存当前进程最近访问过的一组页表项

命中、不命中、命中率

访问内存有效时间EAT：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间

平均存取时间计算：访问内存时间t1，检索快表时间t2

* 命中：耗费时间是 t1+t2
* 不命中：耗费时间就是 t1+t2+t2
* 因此平均存取时间就是 $(t1+t2)×命中率+(t1+t2+t2)×(1-命中率)$ 

二级页表：页表过多没有足够大的连续空间

多级页表：64位机器一般采用多级页表（4级以上）

反置页表IPT：避免一个进程一个页表，一般采用Hash表来检索。IPT是为主存中的每一个物理块建立一个页表项并按照块号排序；该表每个表项包含正在访问该物理块的进程标识、页号及特征位,用来完成主存物理块到访问进程的页号的转换。

* 地址转换过程：给出进程标识和页号,用它们去比较IPT,若整个反置页表中未能找到匹配的页表项,说明该页不在主存,产生请求调页中断,请求操作系统调入;否则，该表项的序号便是物理块号,块号加上位移,便形成物理地址。

> 反置页表没看懂
 
## 4.5 分段式存储管理

分段存储管理方式的引入

* 方便编程
* 分段共享：①一般实现程序和数据共享时都是以信息的逻辑单位（过程、函数或文件）为基础的。②在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整意义，因而不便于实现信息共享。③段是信息的逻辑单位，可以为共享过程建立一个独立的段，更便于实现程序和数据的共享
* 分段保护：①对内存中的信息的保护，同样也是对信息的逻辑单位进行保护。②采用分段存储管理，对实现保护，将是更有效和方便。    
* 动态链接：程序运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段调入内存并进行链接。
* 动态增长：在实际使用中，往往有些段，特别是数据段会随着程序的运行不断增大，而这种增长事先并不知晓会增长到多大，采用其它存储管理方式是难以应付的，而分段存储管理却能较好的解决这一问题。

分段管理：管理由若干分段组成的作业，且按分段来进行存储分配。关键在于，如何保证分段(二维)地址空间中的一个作业在线性(一维)的存储空间中正确运行。也就是说，如何把分段地址结构变换成线性的地址结构，和分页管理一样，可采用动态重定位技术，即通过地址变换机构来实现

段表：实现从逻辑段刀物理内存区的映射。通常放在内存中。分段制造了二维空间，而内存是一维的

地址变换机构：①根据段表寄存器的内容找到该作业的段表地址；  ②利用有效地址中的段号2作为检索段表的索引，得到该段在主存的起始地址；  ③将段的主存起始地址和位移量W相加，即得访问主存的物理地址  

![image-20230609112757575](https://github.com/LyrisLaurier/notes/assets/94295495/7fc0c85c-2c1a-44f5-ab89-f1fb5ad42f7f)

也可设置联想存储器/快表，提高访问速度

信息共享

* 可重入代码：  是一种允许多个进程同时访问的代码（可共享），且是一种不允许任何进程对其进行修改的代码。即代码区可以用同一部分

> 一个多用户系统可接纳40个用户，它们都执行一个文本编辑程序(ED)，ED代码共160K，每个用户还有40K的数据区(DA)。
>
> （1）不采用信息共享时需占用的内存空间？ ( 160K + 40K ) \* 40 = 8000K
>
> （2）采用信息共享（若ED可共享）后占用的内存空间？ 160K + 40K \* 40 = 1760K

* 分页共享：假定页面大小为4K，两个用户，那么B上题的代码160KB就占40个页面。数据区40KB占10个页面。

  对于代码页面，它必须把共享的代码安排到所有共享它的作业地址空间中相同页号的页面中。即共享代码所在的地址空间必须重叠
  
  ![image-20230609113426152](https://github.com/LyrisLaurier/notes/assets/94295495/e4e8c78b-f127-4aad-8f50-47890b839bb5)

* 分段共享：分段的共享是通过两个作业段表的相应表目都指向COS过程的同一物理副本来实现的

  ![image-20230609113553818](https://github.com/LyrisLaurier/notes/assets/94295495/9e21553f-a7cc-4292-a4d2-5ea2812b8873)

> 分段共享没看太明白

段页式存储管理方式：先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号

引入

* 分页管理内存管理效率高：没有外零头；内零头小
* 分段管理符合模块化思想：每个分段都具备完整的功能；方便代码共享、保护；没有内零头，存在外零头

逻辑地址结构：段号S、段内页号P、页内相对地址(位移量)W  ![image-20230609143929136](https://github.com/LyrisLaurier/notes/assets/94295495/71ed5ffb-8e6a-43e7-8295-9bceb13fedb6)

地址变换：设置有段表、段内页表

1. 从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表
2. 根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址
3. 再根据逻辑地址中指定的页号检索该页表，找到对应页所在的物理块号
4. 最后用物理块号加上逻辑地址中指定的页内偏移量，形成物理地址

![image-20230609144737044](https://github.com/LyrisLaurier/notes/assets/94295495/9a8ae5bf-9582-4637-b69a-aa89099f76eb)

在段页式存储管理方式中，每访问一次数据，需访问3次内存：一次访问内存中的段表，第二次访问内存中的页表，第三次访问相应数据→设置快表，包含段号、页号、物理块号

> 带中断的地址变换过程

段页式存储管理方式的评价

对换：把内存中暂不能运行的进程或暂时不用和程序和数据，换到外存上，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的程序和数据，换入内存

* 整体对换/进程对换
* 页面对换/分段对换

需实现的功能

* 对换空间的管理：外存分为文件区和对换区，文件区离散分配，对换区连续分配。

  * 对换区：空闲分区表/链的表目包含对换分区首址、对换分区长度，基本单位盘块。

    分配算法有首次适应算法、循环首次适应算法、最佳适应算法

* 进程的换入

  * 选择：选阻塞或睡眠状态的进程，若无则选就绪状态
  * 换入

* 进程的换出

## 4.6 虚拟存储器

> 虚拟存储管理——虚拟存储器、虚拟存储技术、程序局部性原理、请求分页管理、请求分段管理、页面置换算法、抖动（颠簸）

提出：①一个程序要求的存储容量超过整个内存空间；②有大量的作业需要装入内存运行而内存空间不足

内存扩充方法：物理扩充、逻辑扩充

基本工作情况：基于局部性原理，仅装入当前运行要的页/段，其余放外存→运行所需不在内存就请求调页/段→若内存满则利用置换功能换掉不用的

虚拟存储器：是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。

> 虚拟存储管理以页/段为单位，对换技术以进程为单位

虚拟存储器的实现方法

* 请求分页系统：在纯分页系统的基础上增加了请求调页、页面置换两大功能所形成的页式虚拟存储系统。为实现请求调页、页面置换两大功能。硬件支持、需得到OS的支持

* 请求分段系统：在纯分段系统的基础上增加了请求调段、分段置换两大功能所形成的段式虚拟存储系统。硬件支持、需得到OS的支持

* 段页式虚拟系统：建立在段页式系统的基础上，通过增加了请求调页、页面置换两大功能所形成的段页式虚拟存储系统

虚拟存储器的特征

* 多次性：多次性是指一个作业被分成多次调入内存运行。 
* 对换性：对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。 
* 虚拟性：虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。

> 虚拟性是以多次性和对换性为基础的；而多次性和对换性又必须建立在离散分配的基础上

典型问题：抖动-频繁的换入换出。原因是选择的页面或段不恰当

## 4.7 请求分页存储管理系统

硬件支持

* 页表机制 ![image-20230609152619401](https://github.com/LyrisLaurier/notes/assets/94295495/4331252f-410e-47f0-ab23-4885bb930eff)
* 缺页中断机构，缺页中断处理过程
* 地址变换机构

内存分配策略和算法

* 最小物理块数的确定
* 物理块的分配策略：固定分配局部置换、可变分配全局置换、可变分配局部置换
* 物理块的分配算法：平均分配算法、按比例分配算法、考虑优先权的分配算法（一部分按比例一部分考虑考虑优先权）

调页策略

* 何时装入：预调页、请求调页
* 何处调入：
  * 系统拥有足够的对换区空间：全从对换区调入
  * 缺少足够的对换区空间：不会修改的从文件区调入
  * UNIX方式：进程相关、未运行过的从文件区，运行过被换出的从对换区
* 调入过程：缺页中断→中断处理程序转入缺页中断处理程序→内存满则置换（如果页修改需要写回磁盘）→调入，写入快表→物理地址

页面置换算法

* 最佳(优)置换算法：从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面
* 先进先出（FIFO）页面置换算法：选择作业中驻留时间最长(即最老)的一页淘汰
* 最近最久未使用（LRU）置换算法：选择在最近一段时间内最久不用的页面予以淘汰
* Clock置换算法
* 改进型Clock置换算法
* 其它置换算法

> 去看PPT上的例题，大概在P212页往后

## 4.8 缺页率对有效访问时间的影响

缺页中断处理时间：缺页中断服务时间+页面传送时间（包括读缺页和写置换页的时间）+进程重新执行的时间，其他二者时间较短因此仅考虑页面传送时间。

内存读写周期为t，查找快表时间为λ，缺页中断处理时间为ɛ

* 在内存且在快表，只需访问一次内存：EAT=λ+t
* 在内存不在快表，访问两次内存（一次读页表一次读数据），更新快表：EAT=2(λ+t)
* 不在内存：查快表、查页表、处理缺页中断、更新快表、访问物理地址：EAT=2(λ+t)+ɛ
* 快表命中率为α，缺页中断率为f：EAT= λ + α t + (1- α)[t + f(t +ɛ +λ) + (1-f)(t +λ)]

CPU利用率急剧下降-抖动/颠簸：原因是系统内进程增多

抖动：局部抖动、全局抖动，产生原因

工作集模型

## 4.9 请求分段存储管理方式

工作原理：请求分段系统中，程序运行之前，只需先调入若干个分段（不必调入所有的分段），便可启动运行。当所访问的段不在内存中时，可请求OS将所缺的段调入内存

硬件支持：

* 请求分段的段表机制 ![image-20230609162728473](https://github.com/LyrisLaurier/notes/assets/94295495/a25b0c66-f1ff-4b80-8dcb-1f0fb2753b69)
* 缺段中断机构
* 地址变换机构。

分段的共享与保护：

* 共享段表分配与回收
* 分段保护：越界检查、存取控制检查、环保护机构

> 分段的共享与保护好像不是重点，没细看

*****

# 5 IO系统/设备管理

> 重难点：
>
> * 虚拟设备和SPOOLing 技术（了解）
>   * 什么是虚拟设备
>   * 什么是假脱机（SPOOLing）技术，SPOOLing系统的组成
>   * 如何利用SPOOLing技术实现共享打印机
> * 磁盘调度
>   * 磁盘调度的目标
>   * 磁盘访问时间的计算
>   * nFCFS、SSTF、SCAN、CSCAN 等算法的应用及这些调度算法的演变过程，分别解决了哪些问题；各算法的性能比较（寻道长度的计算）
>
> 典型问题：
>
> * 各种I/O 控制方式的比较
> * 为什么引入缓冲区
> * 缓冲如何提高I/O 速度
> * 为什么引入设备独立性，如何实现
> * 什么是虚拟设备，实现虚拟设备的关键技术
> * SPOOLing技术的组成，如何利用SPOOLing 技术实现共享打印机
> * 对各种磁盘调度算法，计算访问次序和平均寻道时间，性能
> * 磁盘访问时间的组成和计算

## 5.1 I/O系统的功能、模型和接口 

基本功能

层次结构和模型

总体设计目标：高效性、通用性

接口：块设备接口、字符设备接口、网络通信接口

## 5.2 I/O设备和设备控制器

> 基本概念——设备管理重要性、设备独立性、设备分类、设备管理任务、设备管理功能
>
> I/O软件组成——用户进程、与设备无关软件、设备驱动程序、中断处理程序、设备控制器

设备分类

* 使用特性：存储设备、输入/输出设备
* 传输速率：低速设备、中速设备、高速设备
* 共享属性：独占设备（临界资源）、共享设备、虚拟设备

设备控制器

* 功能：接收CPU命令，控制I/O设备工作，解放CPU
* 组成：设备控制器与处理机的接口、设备控制器与设备的接口、I/O逻辑

I/O通道：字节多路通道、数组选择通道、数组多路通道

## 5.3 中断

> 见计组笔记

## 5.4 设备驱动程序

功能

1. 接收由I/O进程发来的命令和参数, 并将命令中的抽象要求转换为具体要求。
2. 检查用户I/O请求的合法性,了解I/O设备的状态,传递有关参数,设置设备的工作方式。
3. 发出I/O命令并检查设备状态。
4. 及时响应由控制器或通道发来的中断请求并处理。

特点

1. 驱动程序主要是指在请求I/O的进程与设备控制器之间的一个通信和转换程序。
2. 驱动程序与设备控制器和I/O设备的硬件特性紧密相关,因而对不同类型的设备应配置不同的驱动程序。
3. 驱动程序与I/O设备所采用的I/O控制方式紧密相关，常用中断驱动和DMA方式。
4. 由于驱动程序与硬件紧密相关,因而其中的一部分必须用汇编语言书写。
5. 驱动程序允许可重入。

设备处理方式：一类设备一个进程，整个系统一个进程，不专门设置设备处理进程只设置设备处理程序/模块

处理过程：抽象要求转换为具体要求→检查I/O请求的合法性→读出和检查设备的状态→传送必要的参数→工作方式的设置→启动I/O设备

I/O控制方式

* 程序I/O方式
* 中断方式
* 直接存储器访问方式（DMA）
* 通道方式

DMA方式用于块设备

* 特点：①基本单位数据块②数据从设备直接送入内存③传送开始或结束时才要CPU干预
* 组成：主机与DMA控制器接口、DMA控制器与块设备接口、I/O控制逻辑

I/O通道方式

## 5.5 与设备无关的I/O软件

与设备无关软件/设备独立性/设备无关性：应用程序独立于具体使用的物理设备，即用户在编程序时使用的设备与实际设备无关

* 逻辑设备、物理设备
* 优点：灵活性；易于实现重定向
* 主要功能

设备分配的数据结构







## 5.6 用户层的I/O软件



## 5.7 缓冲管理



## 5.8 磁盘存储器的性能和调度










